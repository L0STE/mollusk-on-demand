//! Example usage pattern for beethoven
//!
//! This demonstrates how to structure your program to use beethoven's trait-based
//! protocol abstraction for deposits across Kamino, Jupiter, and other protocols.

#![no_std]

use core::mem::size_of;
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    ProgramResult,
};

// Import beethoven traits and protocol implementations
use beethoven::{Deposit, Kamino, KaminoDepositAccounts, JupiterEarn, JupiterEarnDepositAccounts};

/// Your program's deposit accounts (protocol-agnostic)
pub struct DepositAccounts<'info> {
    pub authority: &'info AccountInfo,
}

impl<'info> TryFrom<&'info [AccountInfo]> for DepositAccounts<'info> {
    type Error = ProgramError;

    fn try_from(accounts: &'info [AccountInfo]) -> Result<Self, Self::Error> {
        let [authority, ..] = accounts else {
            return Err(ProgramError::NotEnoughAccountKeys);
        };

        Ok(Self { authority })
    }
}

/// Your program's deposit instruction data
pub struct DepositData {
    pub amount: u64,
}

impl<'a> TryFrom<&'a [u8]> for DepositData {
    type Error = ProgramError;

    fn try_from(data: &'a [u8]) -> Result<Self, Self::Error> {
        if data.len().ne(&size_of::<u64>()) {
            return Err(ProgramError::InvalidInstructionData);
        }

        let amount = u64::from_le_bytes(data.try_into().unwrap());

        Ok(Self { amount })
    }
}

/// Main deposit instruction struct
///
/// This contains both your program-specific accounts and the protocol-specific
/// CPI accounts. The protocol type parameter `P` determines which protocol to use.
pub struct DepositInstruction<'info, P: Deposit<'info>> {
    /// Your program's accounts (authority, etc.)
    accounts: DepositAccounts<'info>,
    /// Protocol-specific CPI accounts (Kamino, Jupiter, etc.)
    cpi_accounts: P::Accounts,
    /// Parsed instruction data
    instruction_data: DepositData,
}

impl<'a, P: Deposit<'a>> TryFrom<(&'a [u8], &'a [AccountInfo])> for DepositInstruction<'a, P>
where
    P::Accounts: TryFrom<&'a [AccountInfo], Error = ProgramError>,
{
    type Error = ProgramError;

    fn try_from((data, accounts): (&'a [u8], &'a [AccountInfo])) -> Result<Self, Self::Error> {
        // Parse your program's accounts (just authority in this case)
        let accounts = DepositAccounts::try_from(&accounts[..1])?;

        // Parse protocol-specific CPI accounts from remaining accounts
        let cpi_accounts = P::Accounts::try_from(&accounts[1..])?;

        // Parse instruction data
        let instruction_data = DepositData::try_from(data)?;

        Ok(Self {
            accounts,
            cpi_accounts,
            instruction_data,
        })
    }
}

impl<'a, P: Deposit<'a>> DepositInstruction<'a, P> {
    pub const DISCRIMINATOR: u8 = 0;

    /// Process the deposit instruction
    ///
    /// This will call the appropriate protocol's deposit method based on the type parameter P.
    pub fn process(&self) -> ProgramResult {
        // Perform any program-specific validation here
        // For example, verify the authority is allowed to deposit

        // Call the protocol-specific deposit CPI
        P::deposit(&self.cpi_accounts, self.instruction_data.amount)?;

        Ok(())
    }

    /// Process with PDA signing
    pub fn process_signed(&self, signer_seeds: &[pinocchio::instruction::Signer]) -> ProgramResult {
        // Call the protocol-specific deposit CPI with signing
        P::deposit_signed(&self.cpi_accounts, self.instruction_data.amount, signer_seeds)?;

        Ok(())
    }
}

// ===========================
// Usage Examples
// ===========================

/// Example: Process a Kamino deposit
pub fn process_kamino_deposit(data: &[u8], accounts: &[AccountInfo]) -> ProgramResult {
    // Type annotation specifies Kamino protocol
    let deposit = DepositInstruction::<Kamino>::try_from((data, accounts))?;
    deposit.process()
}

/// Example: Process a Jupiter Earn deposit
pub fn process_jupiter_deposit(data: &[u8], accounts: &[AccountInfo]) -> ProgramResult {
    // Type annotation specifies JupiterEarn protocol
    let deposit = DepositInstruction::<JupiterEarn>::try_from((data, accounts))?;
    deposit.process()
}

/// Example: Generic deposit function that works with any protocol
pub fn process_deposit<'a, P>(data: &'a [u8], accounts: &'a [AccountInfo]) -> ProgramResult
where
    P: Deposit<'a>,
    P::Accounts: TryFrom<&'a [AccountInfo], Error = ProgramError>,
{
    let deposit = DepositInstruction::<P>::try_from((data, accounts))?;
    deposit.process()
}

/// Example: Main entrypoint showing how to route to different protocols
pub fn entrypoint(
    _program_id: &[u8; 32],
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // First byte is the discriminator
    let (discriminator, data) = instruction_data.split_first()
        .ok_or(ProgramError::InvalidInstructionData)?;

    match discriminator {
        &DepositInstruction::<Kamino>::DISCRIMINATOR => {
            // Route to Kamino
            process_deposit::<Kamino>(data, accounts)
        }
        // Add other protocol discriminators here
        // 1 => process_deposit::<JupiterEarn>(data, accounts),
        _ => Err(ProgramError::InvalidInstructionData),
    }
}
